# Django Rest Framework with DDD and CQRS REST API
[![codecov](https://codecov.io/gh/AdriRRP/joinup-challenge/graph/badge.svg?token=HfvheNjVR0)](https://codecov.io/gh/AdriRRP/joinup-challenge)


## Table of Contents
1. [Business Requirements](#business-requirements)
2. [Project Approach](#project-approach)
3. [Project Structure](#project-structure)
4. [Endpoints](#endpoints)
5. [Application components](#application-components)
6. [Build and test the application](#build-and-test-the-application)


## Business Requirements

This repository is a proposal for the technical challenge launched by Joinup.
The challenge requirements are the following:

- Context
  - High availability / High performance backend
    - The system must work 24/7
    - The system must handle between 2500 and 3500 requests per minute
  - The system must be very fast in responding to requests
  - Optimized database queries, as they are usually the bottleneck
- Requirements
  - Develop a REST API for user management
  - Use Python with Django and Django Rest Framework
  - The API must have 2 endpoints:
    - A **user signup** endpoint
      - Proposed route: `^/api/VERSION_API/signup/$`
      - User fields: `name`, `surname`, `email`, `phone` and `hobbies`
      - The `email` field must be validated through a confirmation email
      - The `phone` field must be validated through a confirmation SMS
      - Sending emails and SMS is supposed to take a long time, so they must be implemented **asynchronously**
      - There must be **separate configurations** for the development and production environment
    - An **access to user profile** endpoint
      - Proposed route: `^/api/VERSION_API/profile/$`
      - User fields: `name`, `surname`, `email`, `phone`, `hobbies`, `email_verified` and `phone_verified`
  - Use the best development practices you know

## Project Approach

As a background of good practices I will use my own interpretation of *Domain Driven Design* influenced by the wonderful CodelyTV Pro courses.

Also since there are high availability and high performance requirements, I will use CQRS to make an optimized reading model and run heavy tasks in the background.

It should be noted that the use of Domain Driven Design and CQRS advocates avoiding the use of active record and ORMs, which is one of the base parts of Django and Django Rest Framework.

I am aware that these features are one of the strong points when it comes to achieving quick results developing with Django and Django Rest Framework, but they can be counterproductive when optimizing aspects related to performance and scalability.

For this reason I have decided not to use the native mechanisms of Django and Django Rest Framework and to use patterns recommended by Domain Driven Design and CQRS.

## Project Structure

Because Django and Django Rest Framework according to Domain Driven Design are implementation details of the application, so they will go within the infrastructure part of it.

This will allow the decoupling of the business logic from the framework that implements it, guaranteeing the principles of Open Closed and Dependency Inversion of SOLID.

The following directory structure has been chosen:

```bash
├── app                         # Applications stored in this repository
│   └── challenge               # Application for bounded context `challenge`
├── docs                        # Documentation
├── env                         # (ignored by git) Virtual environment for development environment
├── etc                         # Application configuration and aux files 
├── lib                         # Libraries stored in this repository
│   ├── challenge               # Main library of bounded context `challenge`
│   │   ├── email_verification  # Email verification module
│   │   ├── phone_verification  # Phone verification module
│   │   └── user                # User module
│   └── shared                  # Common code for all bounded context
└── tests                       # Tests folder
    ├── app                     # Applications related tests
    │   └── challenge           # Tests for application of bounded context `challenge`
    └── lib                     # Libraries related tests
        ├── challenge           # Tests for library of bounded context `challenge`
        └── shared              # Tests for common code
```

## Endpoints

The application has the following published endpoints:

- `GET` `.../api/v1/profile/'`: Gets the list of all users registered in the application.
- `GET` `.../api/v1/profile/<user-id>`: Gets the user corresponding to the id _<user-id>_.
- `GET` `.../api/v1/email-verification/<verification-code>`: Verifies a user's email. The _<verification-code>_ is automatically generated by the application and is exposed to the user in the form of the link in the verification message.
- `GET` `.../api/v1/phone-verification/<verification-code>`: Verifies a user's phone. The _<verification-code>_ is automatically generated by the application and is exposed to the user in the form of the link in the verification message.
- `PUT` `.../api/v1/signup/'`: Receive a json with a user's information to proceed with registration.

## Application components

The application consists of the following services:

External services (infrastructure):

- **mongo**: MongoDB will be the data backend.
- **rabbitmq**: RabbitMQ will be the bus for commands and events.
- **mail-service**: (production only) MailHog is used as a test SMTP for sending emails.

Django application:

- **django-server**: Use the containerized challenge app (_./Dockerfile_). Django main entry point.

Application Commands Handlers (heavy operations that do not need to be synchronous):

- **django-user-creator**: Use the containerized challenge app (_./Dockerfile_). Django subcommand (_manage.py_) to create users. Generates events of type _user created_.
- **django-email-verification-acceptor**: Use the containerized challenge app (_./Dockerfile_). Django subcommand (_manage.py_) to accept email verifications. Generates events of type _email verification created_.
- **django-phone-verification-acceptor**: Use the containerized challenge app (_./Dockerfile_). Django subcommand (_manage.py_) to accept phone verifications. Generates events of type _phone verification created_.

Application Event Handlers (respond to state changes in the application).

- **django-on-user-created-email-verification**: Use the containerized challenge app (_./Dockerfile_). Listens for events of type _user created_. When a user is created it creates an email verification.
- **django-on-user-created-phone-verification**: Use the containerized challenge app (_./Dockerfile_). Listens for events of type _user created_. When a user is created it creates a phone verification.
- **django-on-email-verification-created**: Use the containerized challenge app (_./Dockerfile_). Listens for events of type _email verification created_. When a email verification is created it sends a verification email.
- **django-on-phone-verification-created**: Use the containerized challenge app (_./Dockerfile_). Listens for events of type _phone verification created_. When a phone verification is created it sends a verification sms.
- **django-on-email-verification-accepted**: Use the containerized challenge app (_./Dockerfile_). Listens for events of type _email verification accepted_. When a email verification is accepted it updates user email_verified.
- **django-on-phone-verification-accepted**: Use the containerized challenge app (_./Dockerfile_). Listens for events of type _phone verification accepted_. When a phone verification is accepted it updates user phone_verified.


## Build and test the application

The application is containerized using docker, and orchestrated using docker compose.
The only requirement to be able to run it is to have [Docker Engine](https://docs.docker.com/engine/install/) installed.

It should be noted that there are 2 execution modes, one for the _development_ environment and one for the _production_ environment (there is not much difference between the two, but this distinction is made to illustrate where everything would be located).

To run the application in _development_ mode we must execute:

```bash
docker compose -f compose.dev.yaml up -d
```

To run the application in _production_ mode we must execute:

```bash
docker compose -f compose.prod.yaml up -d
```

> **_IMPORTANT:_**  Because the application has been developed in an environment with ARM64 architecture,
> the `mail-service` service uses the specific `richarvey/mailhog` image for the mail server in the `compose.prod.yaml` file. If the machine you run this repo on has x86 architecture, use the `mailhog/mailhog` image instead.

From now on we will use the production environment (compose.prod.yaml file) as an example, but the commands are equally valid for the development environment.

Once initialized, we can check the status of each service with the command:

```bash
docker compose -f compose.prod.yaml logs -f <service>
```

It can be tedious, but it is advisable to ensure that all services have been initialized correctly.

If any of the services have failed to start, we can restart that specific service with the commands:

```bash
docker compose -f compose.prod.yaml down <service>
docker compose -f compose.prod.yaml up -d <service>
```

Once everything is working correctly, we can perform a functional test:

1. Access the http://127.0.0.1:8000/api/v1/profile/ endpoint using a web browser. You will be able to verify that there are 2 users in the system.
2. Access the http://127.0.0.1:8000/api/v1/signup/ endpoint to create a new user using `PUT` method. For example you can put the following user:
```json
{
    "id": "83239b41-9416-448c-9462-65805378fab8",
    "name": "New",
    "surname": "One",
    "email": "reciever@todomain.com",
    "phone": "+34 666 666 003",
    "hobbies": "All"
}
```

3. You must have received a response like this:

```json
{
    "status": "Request accepted, you will be notified when finished"
}
```
This means that everything went well and that the user creation is being managed in the background.


4. Once the user is created in the database, a _user created_ event will be generated. After this, an email and a confirmation SMS will be sent with a link to verify user email and phone.
5. If the production environment is being used, we can see the email with the link received at http://localhost:8025/. If not, we can see the confirmation link in the logs of the `django-on-email-verification-created` service:
```bash
docker compose -f compose.prod.yaml logs -f django-on-email-verification-created
```
6. Click on the indicated link to verify the new user's email.
7. Check the users endpoint (http://127.0.0.1:8000/api/v1/profile/) to verify that the email has been verified.
8. In the case of SMS notifications, no real service has been implemented, so we must consult the verification link in the service logs `django-on-phone-verification-created`:
```bash
docker compose -f compose.prod.yaml logs -f django-on-phone-verification-created
```
9. Click on the indicated link to verify the new user's phone.
10. Check the users endpoint (http://127.0.0.1:8000/api/v1/profile/) to verify that the phone has been verified.